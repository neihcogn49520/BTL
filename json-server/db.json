{
    "posts": [{
            "content": "Data Structures (I)",
            "id": 1,
            "category": "DSI",
            "data": [{
                "content1": "Stack Data Structures",
                "val": "1",
                "bai1": [{
                    "title": "In this tutorial, you will learn about the stack data structure.",
                    "noidung": [{
                        "DN": "A stack is a linear data structure that follows the principle of Last In First Out (LIFO). This means the last element inserted inside the stack is removed first.<br>You can think of the stack data structure as the pile of plates on top of another.",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/stack-of-plates_0.png",
                        "DN1": "Here, you can:<br>- Put a new plate on top<br>- Remove the top plate<br>And, if you want the plate at the bottom, you must first remove all the plates on top. This is exactly how the stack data structure works.",
                        "methods": "In programming terms, putting an item on top of the stack is called push and removing an item is called pop.<br>In the above image, although item 3 was kept last, it was removed first. This is exactly how the LIFO (Last In First Out) Principle works.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/stack.png",
                        "work": "The operations work as follows:<br>1. A pointer called TOP is used to keep track of the top element in the stack.<br>2. When initializing the stack, we set its value to -1 so that we can check if the stack is empty by comparing TOP == -1.<br>3. On pushing an element, we increase the value of TOP and place the new element in the position pointed to by TOP.<br>4. On popping an element, we return the element pointed to by TOP and reduce its value.<br>5. Before pushing, we check if the stack is already full.<br>6. Before popping, we check if the stack is already empty",
                        "operation": "There are some basic operations that allow us to perform different actions on a stack.<br>- Push: Add an element to the top of a stack<br>- Pop: Remove an element from the top of a stack<br>- IsEmpty: Check if the stack is empty<br>- IsFull: Check if the stack is full<br>- Peek: Get the value of the top element without removing it",
                        "complex1": "Stack Implementations in C++<br><br>The most common stack implementation is using arrays, but it can also be implemented using lists.",
                        "complex2": "// Stack implementation in C++<br><br>#include <stdlib.h><br>#include <iostream><br>using namespace std;<br><br>#define MAX 10<br>int size = 0;<br><br>// Creating a stack<br>struct stack {<br>  int items[MAX];<br>  int top;<br>};<br>typedef struct stack st;<br><br>void createEmptyStack(st *s) {<br>  s->top = -1;<br>}<br><br>// Check if the stack is full<br>int isfull(st *s) {<br>  if (s->top == MAX - 1)<br>    return 1;<br>  else<br>    return 0;<br>}<br><br>// Check if the stack is empty<br>int isempty(st *s) {<br>  if (s->top == -1)<br>    return 1;<br>  else<br>    return 0;<br>}<br><br>// Add elements into stack<br>void push(st *s, int newitem) {<br>  if (isfull(s)) {<br>    cout << “STACK FULL”;<br>  } else {<br>    s->top++;<br>    s->items[s->top] = newitem;<br>  }<br>  size++;<br>}<br><br>// Remove element from stack<br>void pop(st *s) {<br>  if (isempty(s)) {<br>    cout << “\n STACK EMPTY \n”;<br>  } else {<br>    cout << “Item popped= ” << s->items[s->top];<br>    s->top--;<br>  }<br>  size--;<br>  cout << endl;<br>}<br><br>// Print elements of stack<br>void printStack(st *s) {<br>  printf(“Stack: ”);<br>  for (int i = 0; i < size; i++) {<br>    cout << s->items[i] << “  ”;<br>  }<br>  cout << endl;<br>}<br><br>// Driver code<br>int main() {<br>  int ch;<br>  st *s = (st *)malloc(sizeof(st));<br><br>  createEmptyStack(s);<br><br>  push(s, 1);<br>  push(s, 2);<br>  push(s, 3);<br>  push(s, 4);<br><br>  printStack(s);<br><br>  pop(s);<br><br>cout << “\nAfter popping out\n”;<br>printStack(s);<br>}",
                        "complex3": "For the array-based implementation of a stack, the push and pop operations take constant time, i.e. O(1).",
                        "application": "Although stack is a simple data structure to implement, it is very powerful. The most common uses of a stack are:<br>- To reverse a word - Put all the letters in a stack and pop them out. Because of the LIFO order of stack, you will get the letters in reverse order.<br>- In compilers - Compilers use the stack to calculate the value of expressions like 2 + 4 / 5 * (7 - 9) by converting the expression to prefix or postfix form.<br>- In browsers - The back button in a browser saves all the URLs you have visited previously in a stack. Each time you visit a new page, it is added on top of the stack. When you press the back button, the current URL is removed from the stack, and the previous URL is accessed."
                    }]
                }],
                "content2": "Queue Data Structures",
                "val1": "2",
                "bai2": [{
                    "title": "In this tutorial, you will learn what a queue is.",
                    "noidung": [{
                        "DN": "A priority queue is a special type of queue in which each element is associated with a priority value. And, elements are served on the basis of their priority. That is, higher priority elements are served first.<br>However, if elements with the same priority occur, they are served according to their order in the queue.",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/queue.png",
                        "DN1": "In the above image, since 1 was kept in the queue before 2, it is the first to be removed from the queue as well. It follows the FIFO rule.<br>In programming terms, putting items in the queue is called enqueue, and removing items from the queue is called dequeue.",
                        "methods": "Queue operations work as follows:<br>- two pointers FRONT and REAR<br>- FRONT track the first element of the queue<br>- REAR track the last element of the queue<br>- initially, set value of FRONT and REAR to -1",
                        "operation": "A queue is an object (an abstract data structure - ADT) that allows the following operations:<br>- Enqueue: Add an element to the end of the queue<br>- Dequeue: Remove an element from the front of the queue<br>- IsEmpty: Check if the queue is empty<br>- IsFull: Check if the queue is full<br>- Peek: Get the value of the front of the queue without removing it",
                        "enope": "- check if the queue is full<br>- for the first element, set the value of FRONT to 0<br>- increase the REAR index by 1<br>- add the new element in the position pointed to by REAR",
                        "deope": "- check if the queue is empty<br>- return the value pointed by FRONT<br>- increase the FRONT index by 1<br>- for the last element, reset the values of FRONT and REAR to -1",
                        "complex1": "We usually use arrays to implement queues in C++, we use lists.",
                        "complex2": "// Queue implementation in C++<br><br>#include <iostream><br>#define SIZE 5<br><br>using namespace std;<br><br>class Queue {<br>   private:<br>  int items[SIZE], front, rear;<br><br>   public:<br>  Queue() {<br>    front = -1;<br>    rear = -1;<br>  }<br><br>  bool isFull() {<br>    if (front == 0 && rear == SIZE - 1) {<br>     return true;<br>    }<br>    return false;<br>  }<br><br>  bool isEmpty() {<br>    if (front == -1)<br>     return true;<br>    else<br>     return false;<br>  }<br><br>  void enQueue(int element) {<br>    if (isFull()) {<br>      cout << “Queue is full”;<br>    } else {<br>      if (front == -1) front = 0;<br>      rear++;<br>      items[rear] = element;<br>      cout << endl << “Inserted”  << element << endl;",
                        "complex3": "<br><br>  int deQueue() {<br>    int element;<br>    if (isEmpty()) {<br>      cout << “Queue is empty” << endl;<br>      return (-1);<br>    } else {<br>      element = items[front];<br>      if (front >= rear) {<br>        front = -1;<br>        rear = -1;<br>      } /* Q has only one element, so we reset the queue after deleting it. */<br>      else {<br>        front++;<br>      }<br>      cout << endl<br>        << “Deleted -> ” << element << endl;<br>      return (element);<br>    }<br>  }<br><br>  void display() {<br>    /* Function to display elements of Queue */<br>    int i;<br>    if (isEmpty()) {<br>      cout << endl<br>        << “Empty Queue” << endl;<br>    } else {<br>      cout << endl<br>        << “Front index-> ” << front;<br>      cout << endl<br>        << “Items -> ”;<br>      for (i = front; i <= rear; i++)<br>        cout << items[i] << “  ”;<br>      cout << endl << “Rear index->”  << rear << endl;<br>    }<br>  }<br>};<br><br>int main() {<br>  Queue q;<br><br>  //deQueue is not possible on empty queue<br>  q.deQueue();<br><br>  //enQueue 5 elements<br>  q.enQueue(1);<br>  q.enQueue(2);<br>  q.enQueue(3);<br>  q.enQueue(4);<br>  q.enQueue(5);<br><br>  // 6th element can't be added to because the queue is full<br>  q.enQueue(6);<br><br>  q.display();<br><br>  //deQueue removes element entered first i.e. 1<br>  q.deQueue();<br><br>  //Now we have just 4 elements<br>  q.display();<br><br>  return 0;<br>}",
                        "complex4": "The complexity of enqueue and dequeue operations in a queue using an array is O(1). If you use pop(N) in python code, then the complexity might be O(n) depending on the position of the item to be popped.",
                        "application": "- CPU scheduling, Disk Scheduling<br>- When data is transferred asynchronously between two processes.The queue is used for synchronization. For example: IO Buffers, pipes, file IO, etc<br>- Handling of interrupts in real-time systems.<br>- Call Center phone systems use Queues to hold people calling them in order."
                    }]
                }],
                "content3": "Priority Queue",
                "val2": "3",
                "bai3": [{
                    "title": "In this tutorial, you will learn what priority queue is.",
                    "noidung": [{
                        "DN": "A priority queue is a special type of queue in which each element is associated with a priority value. And, elements are served on the basis of their priority. That is, higher priority elements are served first.<br>However, if elements with the same priority occur, they are served according to their order in the queue.",
                        "DN1": "In the above image, since 1 was kept in the queue before 2, it is the first to be removed from the queue as well. It follows the FIFO rule.<br>In programming terms, putting items in the queue is called enqueue, and removing items from the queue is called dequeue.",
                        "DN3": "Assigning Priority Value",
                        "DN31": "Generally, the value of the element itself is considered for assigning the priority. For example,<br><br>The element with the highest value is considered the highest priority element. However, in other cases, we can assume the element with the lowest value as the highest priority element.<br><br>We can also set priorities according to our needs.",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/Introduction.png",
                        "operation": "Basic operations of a priority queue are inserting, removing, and peeking elements.",
                        "oper1": "Inserting an element into a priority queue (max-heap) is done by the following steps.<br><br>- Insert the new element at the end of the tree.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/insert-1_0.png",
                        "oper12": "- Heapify the tree.",
                        "img3": "https://cdn.programiz.com/sites/tutorial2program/files/insert-2_0.png",
                        "oper13": "- For Min Heap, the above algorithm is modified so that parentNode is always smaller than newNode.",
                        "oper2": "Deleting an element from a priority queue (max-heap) is done as follows:<br>- Select the element to be deleted.",
                        "img4": "https://cdn.programiz.com/sites/tutorial2program/files/delete-1_0.png",
                        "oper22": "- Swap it with the last element.",
                        "img5": "https://cdn.programiz.com/sites/tutorial2program/files/delete-2_0.png",
                        "oper23": "- Remove the last element.",
                        "img6": "https://cdn.programiz.com/sites/tutorial2program/files/delete-3.png",
                        "oper24": "- Heapify the tree.",
                        "img7": "https://cdn.programiz.com/sites/tutorial2program/files/delete-4.png",
                        "oper25": "- For Min Heap, the above algorithm is modified so that the both childNodes are smaller than currentNode.",
                        "oper31": "Peek operation returns the maximum element from Max Heap or minimum element from Min Heap without deleting the node.<br>For both Max heap and Min Heap: return rootNode",
                        "oper41": "Extract-Max returns the node with maximum value after removing it from a Max Heap whereas Extract-Min returns the node with minimum value after removing it from Min Heap.",
                        "complex": "Priority queue can be implemented using an array, a linked list, a heap data structure, or a binary search tree. Among these data structures, heap data structure provides an efficient implementation of priority queues.",
                        "complex1": "// Priority Queue implementation in C++<br><br>#include <iostream><br>#include <vector><br>using namespace std;<br><br>// Function to swap position of two elements<br>void swap(int *a, int *b) {<br>   int temp = *b;<br>   *b = *a;<br>   *a = temp;<br>}<br><br>// Function to heapify the tree<br>void heapify(vector<int> &hT, int i) {<br>   int size = hT.size();<br><br>   // Find the largest among root, left child and right child<br>   int largest = i;<br>   int l = 2 * i + 1;<br>   int r = 2 * i + 2;<br>   if (l < size && hT[l] > hT[largest])<br>      largest = l;<br>   if (r < size && hT[r] > hT[largest])<br>      largest = r;<br><br>   // Swap and continue heapifying if root is not largest<br>   if (largest != i) {<br>     swap(&hT[i], &hT[largest]);<br>     heapify(hT, largest);<br>   }<br>}",
                        "complex2": "<br><br>// Function to insert an element into the tree<br>void insert(vector<int> &hT, int newNum) {<br>  int size = hT.size();<br>  if (size == 0) {<br>    hT.push_back(newNum);<br>  } else {<br>    hT.push_back(newNum);<br>    for (int i = size / 2 - 1; i >= 0; i--) {<br>      heapify(hT, i);<br>    }<br>  }<br>}<br><br>// Function to delete an element from the tree<br>void deleteNode(vector<int> &hT, int num) {<br>  int size = hT.size();<br>  int i;<br>  for (i = 0; i < size; i++) {<br>    if (num == hT[i])<br>      break;<br>  }<br>  swap(&hT[i], &hT[size - 1]);<br><br>  hT.pop_back();<br>  for (int i = size / 2 - 1; i >= 0; i--) {<br>    heapify(hT, i);<br>  }<br>}<br><br>// Print the tree<br>void printArray(vector<int> &hT) {<br>  for (int i = 0; i < hT.size(); ++i)<br>    cout << hT[i] << “ ”;<br>  cout << “\n”;<br>}<br><br>// Driver code<br>int main() {<br>  vector<int> heapTree;<br><br>  insert(heapTree, 3);<br>  insert(heapTree, 4);<br>  insert(heapTree, 9);<br>  insert(heapTree, 5);<br>  insert(heapTree, 2);<br><br>  cout << “Max-Heap array: ”;<br>  printArray(heapTree);<br><br>  deleteNode(heapTree, 4);<br><br>  cout << “After deleting an element: ”;<br><br>  printArray(heapTree);<br>}",
                        "application": "Some of the applications of a priority queue are:<br><br>- Dijkstra's algorithm<br><br>- for implementing stack<br><br>- for load balancing and interrupt handling in an operating system<br><br>- for data compression in Huffman code"
                    }]
                }]
            }]
        },
        {
            "content": "Data Structures (II)",
            "id": 2,
            "category": "DSII",
            "data": [{
                "content1": "Single Linked List",
                "val1": "1",
                "bai1": [{
                    "title": "In this tutorial, you will learn about linked list data structure.",
                    "noidung": [{
                        "DN": "A linked list is a linear data structure that includes a series of connected nodes. Here, each node stores the data and the address of the next node.",
                        "DN1": "You have to start somewhere, so we give the address of the first node a special name called HEAD. Also, the last node in the linked list can be identified because its next portion points to NULL.<br>Linked lists can be of multiple types: singly, doubly, and circular linked list. In this article, we will focus on the singly linked list.",
                        "DN2": "Each node has data and a pointer to the next node.",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/linked-list-concept_0.png",
                        "work1": "- Traversal can occur in one way only (forward direction).<br><br>- It requires less space.<br><br>- It can be implemented on the stack.",
                        "work2": "Let's see how each node of the linked list is represented. Each node consists:<br><br>    - A data item<br>    - An address of another node<br><br>Understanding the structure of a linked list node is the key to having a grasp on it.<br>Each struct node has a data item and a pointer to another struct node. Let us create a simple Linked List with three items to understand how this works.<br><br>In just a few steps, we have created a simple linked list with three nodes.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/linked-list-with-data.png",
                        "work3": "The power of a linked list comes from the ability to break the chain and rejoin it. E.g. if you wanted to put an element 4 between 1 and 2, the steps would be:<br>- Create a new struct node and allocate memory to it.<br>- Add its data value as 4<br>Point its next pointer to the struct node containing 2 as the data value<br>- Change the next pointer of '1' to the node we just created.<br>Doing something similar in an array would have required shifting the positions of all the subsequent elements.",
                        "complex": "Single Linked List implementation in C++:",
                        "complex1": "Node is represented as:",
                        "complex12": "struct node {<br>  int data;<br>  struct node *next;<br>}",
                        "complex2": "A three-member singly linked list can be created as:",
                        "complex22": "/* Initialize nodes */<br>struct node *head;<br>struct node *one = NULL;<br>struct node *two = NULL;<br>struct node *three = NULL;<br><br>/* Allocate memory */<br>one = malloc(sizeof(struct node));<br>two = malloc(sizeof(struct node));<br>three = malloc(sizeof(struct node));<br><br>/* Assign data values */<br>one->data = 1;<br>two->data = 2;<br>three->data = 3;<br><br>/* Connect nodes */<br>one->next = two;<br>two->next = three;<br>three->next = NULL;<br><br>/* Save address of first node in head */<br>head = one;",
                        "application": "- Dynamic memory allocation<br><br>- Implemented in stack and queue<br><br>- In undo functionality of softwares<br><br>- Hash tables, Graphs"
                    }]
                }],
                "content2": "Double Linked List",
                "bai2": [{
                    "title": "In this tutorial, you will learn about the doubly linke list.",
                    "noidung": [{
                        "DN": "A doubly linked list is a type of linked list in which each node consists of 3 components:<br>- *prev - address of the previous node<br>- data - data item<br>- *next - address of next node",
                        "img1": "https://cdn.programiz.com/cdn/farfuture/nNhJNDR7OYb-5wiTX-x2gNaPHBy9YWCXJ_ohHDrQn6s/mtime:1620967408/sites/tutorial2program/files/dll-node.png",
                        "oper1": "Insertion on a Doubly Linked List",
                        "ND1": "Pushing a node to a doubly-linked list is similar to pushing a node to a linked list, but extra work is required to handle the pointer to the previous node.<br><br>We can insert elements at 3 different positions of a doubly-linked list:<br><br>- Insertion at the beginning<br><br>- Insertion in-between nodes<br><br>- Insertion at the End<br><br>Suppose we have a double-linked list with elements 1, 2, and 3.",
                        "oper2": "Deletion from a Doubly Linked List",
                        "ND2": "Similar to insertion, we can also delete a node from 3 different positions of a doubly linked list.<br><br>- Delete the First Node of Doubly Linked List<br><br>- Deletion of the Inner Node<br><br>- Delete the Last Node of Doubly Linked List",
                        "complex": "Double Linked List implementation in C++:",
                        "complex1": "A node is represented as",
                        "complex12": "struct node {<br>  int data;<br>  struct node *next;<br>  struct node *prev;<br>}",
                        "complex2": "A three-member doubly linked list can be created as",
                        "complex22": "/* Initialize nodes */<br>struct node *head;<br>struct node *one = NULL;<br>struct node *two = NULL;<br>struct node *three = NULL;<br><br>/* Allocate memory */<br>one = malloc(sizeof(struct node));<br>two = malloc(sizeof(struct node));<br>three = malloc(sizeof(struct node));<br><br>/* Assign data values */<br>one->data = 1;<br>two->data = 2;<br>three->data = 3;<br><br>/* Connect nodes */<br>one->next = two;<br>one->prev = NULL;<br><br>two->next = three;<br>two->prev = one;<br><br>three->next = NULL;<br>three->prev = two;<br><br>/* Save address of first node in head */<br>head = one;",
                        "complex3": "1. Complexity of Insertion Operation",
                        "complex32": "- The insertion operations that do not require traversal have the time complexity of O(1).<br><br>- And, insertion that requires traversal has time complexity of O(n).<br><br>- The space complexity is O(1).",
                        "complex4": "2. Complexity of Deletion Operation",
                        "complex42": "- All deletion operations run with time complexity of O(1).<br><br>- And, the space complexity is O(1).",
                        "application": "1. Redo and undo functionality in software.<br><br>2. Forward and backward navigation in browsers.<br><br>3. For navigation systems where forward and backward navigation is required."
                    }]
                }]
            }]
        },
        {
            "content": "Tree based DSA",
            "id": 3,
            "category": "TreeI",
            "data": [{
                "content1": "Tree Data Structure",
                "bai1": [{
                    "title": "In this tutorial, you will learn about tree data structure.",
                    "noidung": [{
                        "DN": "A tree is a nonlinear hierarchical data structure that consists of nodes connected by edges.",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/tree_0.png",
                        "oper1": "Why Tree Data Structure?",
                        "ND1": "Other data structures such as arrays, linked list, stack, and queue are linear data structures that store data sequentially. In order to perform any operation in a linear data structure, the time complexity increases with the increase in the data size. But, it is not acceptable in today's computational world.<br>Different tree data structures allow quicker and easier access to the data as it is a non-linear data structure.",
                        "oper2": "Tree Terminologies",
                        "ND21": "A node is an entity that contains a key or value and pointers to its child nodes.<br><br>The last nodes of each path are called leaf nodes or external nodes that do not contain a link/pointer to child nodes.<br>The node having at least a child node is called an internal node.",
                        "ND22": "It is the link between any two nodes.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/nodes-edges_0.png",
                        "ND23": "It is the topmost node of a tree.",
                        "ND24": "The height of a node is the number of edges from the node to the deepest leaf (ie. the longest path from the node to a leaf node).",
                        "ND25": "The depth of a node is the number of edges from the root to the node.",
                        "ND26": "The height of a Tree is the height of the root node or the depth of the deepest node.",
                        "img3": "https://cdn.programiz.com/sites/tutorial2program/files/height-depth_1.png",
                        "ND27": "The degree of a node is the total number of branches of that node.",
                        "ND28": "A collection of disjoint trees is called a forest.<br>You can create a forest by cutting the root of a tree.",
                        "img4": "https://cdn.programiz.com/sites/tutorial2program/files/forest_0.png",
                        "oper3": "Types of Tree",
                        "ND3": "- Binary Tree<br>- Binary Search Tree<br>- B-Tree",
                        "application": "1. Binary Search Trees(BSTs) are used to quickly check whether an element is present in a set or not.<br>2. Heap is a kind of tree that is used for heap sort.<br>3. A modified version of a tree called Tries is used in modern routers to store routing information.<br>4. Most popular databases use B-Trees and T-Trees, which are variants of the tree structure we learned above to store their data<br>5. Compilers use a syntax tree to validate the syntax of every program you write."
                    }]
                }],
                "content2": "Binary Tree",
                "bai2": [{
                    "title": "In this tutorial, you will learn about binary tree and its different types.",
                    "noidung": [{
                        "DN": "A binary tree is a tree data structure in which each parent node can have at most two children. Each node of a binary tree consists of three items:<br><br>- data item<br><br>- address of left child<br><br>- address of right child",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/binary_tree_1.png",
                        "oper1": "1. Full Binary Tree",
                        "ND1": "A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/full-binary-tree_0.png",
                        "oper2": "2. Perfect Binary Tree",
                        "ND2": "A perfect binary tree is a type of binary tree in which every internal node has exactly two child nodes and all the leaf nodes are at the same level.",
                        "img3": "https://cdn.programiz.com/sites/tutorial2program/files/perfect-binary-tree_0.png",
                        "oper3": "3. Complete Binary Tree",
                        "ND3": "A complete binary tree is just like a full binary tree, but with two major differences<br><br>1. Every level must be completely filled<br><br>2. All the leaf elements must lean towards the left.<br><br>3. The last leaf element might not have a right sibling i.e. a complete binary tree doesn't have to be a full binary tree.",
                        "img4": "https://cdn.programiz.com/sites/tutorial2program/files/complete-binary-tree_0.png",
                        "oper4": "4. Degenerate or Pathological Tree",
                        "ND4": "A degenerate or pathological tree is the tree having a single child either left or right.",
                        "img5": "https://cdn.programiz.com/sites/tutorial2program/files/degenerate-binary-tree_0.png",
                        "oper5": "5. Skewed Binary Tree",
                        "ND5": "A skewed binary tree is a pathological/degenerate tree in which the tree is either dominated by the left nodes or the right nodes. Thus, there are two types of skewed binary tree: left-skewed binary tree and right-skewed binary tree.",
                        "img6": "https://cdn.programiz.com/sites/tutorial2program/files/skewed-binary-tree_0.png",
                        "oper6": "6. Balanced Binary Tree",
                        "ND6": "It is a type of binary tree in which the difference between the height of the left and the right subtree for each node is either 0 or 1.",
                        "img7": "https://cdn.programiz.com/sites/tutorial2program/files/height-balanced_1.png",
                        "complex1": "Binary Tree Representation",
                        "complex12": "A node of a binary tree is represented by a structure containing a data part and two pointers to other structures of the same type.",
                        "complex13": "// Binary Tree in C++<br><br>#include <stdlib.h><br>#include <iostream><br>using namespace std;<br><br>struct node {<br>  int data;<br>  struct node *left;<br>  struct node *right;<br>};<br><br>// New node creation<br>struct node *newNode(int data) {<br>  struct node *node = (struct node *)malloc(sizeof(struct node));<br><br>  node->data = data;<br><br>  node->left = NULL;<br>  node->right = NULL;<br>  return (node);<br>}<br><br>// Traverse Preorder<br>void traversePreOrder(struct node *temp) {<br>  if (temp != NULL) {<br>    cout << “ ” << temp->data;<br>    traversePreOrder(temp->left);<br>    traversePreOrder(temp->right);<br>  }<br>}<br><br>// Traverse Inorder<br>void traverseInOrder(struct node *temp) {<br>  if (temp != NULL) {<br>    traverseInOrder(temp->left);<br>    cout << “ ” << temp->data;<br>    traverseInOrder(temp->right);<br>  }<br>    }<br><br>// Traverse Postorder<br>void traversePostOrder(struct node *temp) {<br>  if (temp != NULL) {<br>    traversePostOrder(temp->left);<br>    traversePostOrder(temp->right);<br>    cout << “ ” << temp->data;<br>  }<br>}<br><br>int main() {<br>  struct node *root = newNode(1);<br>  root->left = newNode(2);<br>  root->right = newNode(3);<br>  root->left->left = newNode(4);<br><br>  cout << “preorder traversal: ”;<br>  traversePreOrder(root);<br>  cout << “\nInorder traversal: ”;<br>  traverseInOrder(root);<br>  cout << “\nPostorder traversal: ”;<br>  traversePostOrder(root);<br>}",
                        "application": "1. For easy and quick access to data<br><br>2. In router algorithms<br><br>3. To implement heap data structure<br><br>4. Syntax tree"
                    }]
                }],
                "content3": "Binary Search Tree",
                "bai3": [{
                    "title": "In this tutorial, you will learn how Binary Search Tree works.",
                    "noidung": [{
                        "DN1": "Binary search tree is a data structure that quickly allows us to maintain a sorted list of numbers.<br><br>- It is called a binary tree because each tree node has a maximum of two children.<br><br>- It is called a search tree because it can be used to search for the presence of a number in O(log(n)) time.<br><br>The properties that separate a binary search tree from a regular binary tree is<br><br>1. All nodes of left subtree are less than the root node<br><br>2. All nodes of right subtree are more than the root node<br><br>3. Both subtrees of each node are also BSTs i.e. they have the above two properties",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/bst-vs-not-bst.png",
                        "DN2": "The binary tree on the right isn't a binary search tree because the right subtree of the node 3 contains a value smaller than it.",
                        "oper1": "Search Operation",
                        "ND11": "The algorithm depends on the property of BST that if each left subtree has values below root and each right subtree has values above the root.<br><br>If the value is below the root, we can say for sure that the value is not in the right subtree; we need to only search in the left subtree and if the value is above the root, we can say for sure that the value is not in the left subtree; we need to only search in the right subtree.",
                        "ND12": "Let us try to visualize this with a diagram.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/bst-search-1.png",
                        "img3": "https://cdn.programiz.com/sites/tutorial2program/files/bst-search-2.png",
                        "img4": "https://cdn.programiz.com/sites/tutorial2program/files/bst-search-3.png",
                        "img5": "https://cdn.programiz.com/sites/tutorial2program/files/bst-search-1.png",
                        "ND13": "If the value is found, we return the value so that it gets propagated in each recursion step as shown in the image below.<br><br>If you might have noticed, we have called return search(struct node*) four times. When we return either the new node or NULL, the value gets returned again and again until search(root) returns the final result.",
                        "img6": "https://cdn.programiz.com/sites/tutorial2program/files/bst-search-5.png",
                        "ND14": "If the value is not found, we eventually reach the left or right child of a leaf node which is NULL and it gets propagated and returned.",
                        "oper2": "Insert Operation",
                        "ND21": "Inserting a value in the correct position is similar to searching because we try to maintain the rule that the left subtree is lesser than root and the right subtree is larger than root.<br><br>We keep going to either right subtree or left subtree depending on the value and when we reach a point left or right subtree is null, we put the new node there.",
                        "ND22": "The algorithm isn't as simple as it looks. Let's try to visualize how we add a number to an existing BST.",
                        "img7": "https://cdn.programiz.com/sites/tutorial2program/files/bst-insert-1.png",
                        "img8": "https://cdn.programiz.com/sites/tutorial2program/files/bst-insert-2.png",
                        "img9": "https://cdn.programiz.com/sites/tutorial2program/files/bst-insert-3.png",
                        "img10": "https://cdn.programiz.com/sites/tutorial2program/files/bst-insert-4.png",
                        "ND23": "We have attached the node but we still have to exit from the function without doing any damage to the rest of the tree. This is where the return node; at the end comes in handy. In the case of NULL, the newly created node is returned and attached to the parent node, otherwise the same node is returned without any change as we go up until we return to the root.<br><br>This makes sure that as we move back up the tree, the other node connections aren't changed.",
                        "img11": "https://cdn.programiz.com/sites/tutorial2program/files/bst-insert-5.png",
                        "oper3": "Deletion Operation",
                        "ND31": "There are three cases for deleting a node from a binary search tree.",
                        "ocase1": "In the first case, the node to be deleted is the leaf node. In such a case, simply delete the node from the tree.",
                        "ocase2": "In the second case, the node to be deleted lies has a single child node. In such a case follow the steps below:<br><br>1. Replace that node with its child node.<br><br>2. Remove the child node from its original position.",
                        "ocase3": "In the third case, the node to be deleted has two children. In such a case follow the steps below:<br><br>1. Get the inorder successor of that node.<br><br>2. Replace the node with the inorder successor.<br><br>3. Remove the inorder successor from its original position.",
                        "complex1": "// Binary Search Tree operations in C++<br><br>#include <iostream><br>using namespace std;<br><br>struct node {<br>  int key;<br>  struct node *left, *right;<br>};<br><br>// Create a node<br>struct node *newNode(int item) {<br>  struct node *temp = (struct node *)malloc(sizeof(struct node));<br>  temp->key = item;<br>  temp->left = temp->right = NULL;<br>  return temp;<br>}<br><br>// Inorder Traversal<br>void inorder(struct node *root) {<br>  if (root != NULL) {<br>    // Traverse left<br>    inorder(root->left);<br><br>    // Traverse root<br>    cout << root->key << “ -> ”;<br><br>    // Traverse right<br>    inorder(root->right);<br>  }<br>}<br><br>// Insert a node<br>struct node *insert(struct node *node, int key) {<br>  // Return a new node if the tree is empty<br>  if (node == NULL) return newNode(key);<br><br>  // Traverse to the right place and insert the node<br>  if (key < node->key)<br>    node->left = insert(node->left, key);<br>  else<br>    node->right = insert(node->right, key);<br>  return node;<br>}<br><br>// Find the inorder successor<br>struct node *minValueNode(struct node *node) {<br>  struct node *current = node;<br><br>  // Find the leftmost leaf<br>  while (current && current->left != NULL)<br>    current = current->left;<br><br>  return current;<br>}",
                        "complex12": "<br><br>// Deleting a node<br>struct node *deleteNode(struct node *root, int key) {<br>  // Return if the tree is empty<br>  if (root == NULL) return root;<br><br>  // Find the node to be deleted<br>  if (key < root->key)<br>    root->left = deleteNode(root->left, key);<br>  else if (key > root->key)<br>    root->right = deleteNode(root->right, key);<br>  else {<br>    // If the node is with only one child or no child<br>    if (root->left == NULL) {<br>      struct node *temp = root->right;<br>      free(root);<br>      return temp;<br>    } else if (root->right == NULL) {<br>      struct node *temp = root->left;<br>      free(root);<br>      return temp;<br>    }<br><br>    // If the node has two children<br>    struct node *temp = minValueNode(root->right);<br><br>    // Place the inorder successor in position of the node to be deleted<br>    root->key = temp->key;<br><br>    // Delete the inorder successor<br>    root->right = deleteNode(root->right, temp->key);<br>  }<br>  return root;<br>}<br><br>// Driver code<br>int main() {<br>  struct node *root = NULL;<br>  root = insert(root, 8);<br>  root = insert(root, 3);<br>  root = insert(root, 1);<br>  root = insert(root, 6);<br>  root = insert(root, 7);<br>  root = insert(root, 10);<br>  root = insert(root, 14);<br>  root = insert(root, 4);<br><br>  cout << “Inorder traversal: ”;<br>  inorder(root);<br><br>  cout << “\nAfter deleting 10\n”;<br>  root = deleteNode(root, 10);<br>  cout << “Inorder traversal: ”;<br>  inorder(root);<br>}",
                        "complex13": "The space complexity for all the operations is O(n).",
                        "application": "1. In multilevel indexing in the database<br><br>2. For dynamic sorting<br><br>3. For managing virtual memory areas in Unix kernel"
                    }]
                }]
            }]
        },
        {
            "content": "Graph based DSA",
            "id": 4,
            "category": "Graph",
            "data": [{
                "content1": "Graph Data Structure",
                "bai1": [{
                    "title": "In this tutorial, you will learn what a Graph Data Structure is.",
                    "noidung": [{
                        "DN1": "A graph data structure is a collection of nodes that have data and are connected to other nodes.<br><br>Let's try to understand this through an example. On facebook, everything is a node. That includes User, Photo, Album, Event, Group, Page, Comment, Story, Video, Link, Note...anything that has data is a node.<br><br>Every relationship is an edge from one node to another. Whether you post a photo, join a group, like a page, etc., a new edge is created for that relationship.",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/facebook-graph.png",
                        "DN2": "Let's try to understand this through an example. On facebook, everything is a node. That includes User, Photo, Album, Event, Group, Page, Comment, Story, Video, Link, Note...anything that has data is a node.<br>Every relationship is an edge from one node to another. Whether you post a photo, join a group, like a page, etc., a new edge is created for that relationship.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/graph-vertices-edges_0.png",
                        "DN3": "In the graph,",
                        "DN4": "V = {0, 1, 2, 3}<br>E = {(0,1), (0,2), (0,3), (1,2)}<br>G = {V, E}",
                        "oper1": "The most common graph operations are:<br><br>- Check if the element is present in the graph<br><br>- Graph Traversal<br><br>- Add elements(vertex, edges) to graph<br><br>- Finding the path from one vertex to another",
                        "oper2": "Graph Terminologies",
                        "ND21": "Adjacency: A vertex is said to be adjacent to another vertex if there is an edge connecting them. Vertices 2 and 3 are not adjacent because there is no edge between them.<br><br>Path: A sequence of edges that allows you to go from vertex A to vertex B is called a path. 0-1, 1-2 and 0-2 are paths from vertex 0 to vertex 2.<br><br>Directed Graph: A graph in which an edge (u,v) doesn't necessarily mean that there is an edge (v, u) as well. The edges in such a graph are represented by arrows to show the direction of the edge.",
                        "oper3": "Graph Representation",
                        "ND3": "Graphs are commonly represented in two ways:",
                        "ND31": "1. Adjacency Matrix",
                        "ND312": "An adjacency matrix is a 2D array of V x V vertices. Each row and column represent a vertex.<br><br>If the value of any element a[i][j] is 1, it represents that there is an edge connecting vertex i and vertex j.<br><br>The adjacency matrix for the graph we created above is",
                        "img3": "https://cdn.programiz.com/sites/tutorial2program/files/adjacency-matrix_1.png",
                        "ND313": "Since it is an undirected graph, for edge (0,2), we also need to mark edge (2,0); making the adjacency matrix symmetric about the diagonal.<br><br>Edge lookup(checking if an edge exists between vertex A and vertex B) is extremely fast in adjacency matrix representation but we have to reserve space for every possible link between all vertices(V x V), so it requires more space.",
                        "ND32": "2. Adjacency List",
                        "ND321": "An adjacency list represents a graph as an array of linked lists.<br><br>The index of the array represents a vertex and each element in its linked list represents the other vertices that form an edge with the vertex.<br><br>The adjacency list for the graph we made in the first example is as follows:",
                        "img4": "https://cdn.programiz.com/sites/tutorial2program/files/adjacency-list.png",
                        "ND322": "An adjacency list is efficient in terms of storage because we only need to store the values for the edges. For a graph with millions of vertices, this can mean a lot of saved space.",
                        "application1": "1. Adjacency Matrix Applications",
                        "application11": "- Creating routing table in networks<br><br>- Navigation tasks",
                        "application2": "2. Applications of Adjacency List",
                        "application21": "It is faster to use adjacency lists for graphs having less number of edges."
                    }]
                }],
                "content2": "DFS Algorithm",
                "bai2": [{
                    "title": "In this tutorial, you will learn about depth first search algorithm with examples and pseudocode.",
                    "noidung": [{
                        "DN": "Depth first Search or Depth first traversal is a recursive algorithm for searching all the vertices of a graph or tree data structure. Traversal means visiting all the nodes of a graph.",
                        "DN1": "A standard DFS implementation puts each vertex of the graph into one of two categories:<br><br>1. Visited<br><br>2. Not Visited<br><br>The purpose of the algorithm is to mark each vertex as visited while avoiding cycles.<br><br>The DFS algorithm works as follows:<br><br>1. Start by putting any one of the graph's vertices on top of a stack.<br><br>2. Take the top item of the stack and add it to the visited list.<br><br>3. Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.<br><br>4. Keep repeating steps 2 and 3 until the stack is empty.",
                        "oper1": "Depth First Search Example",
                        "ND1": "Let's see how the Depth First Search algorithm works with an example. We use an undirected graph with 5 vertices.",
                        "img1": "https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-0.png",
                        "ND2": "We start from vertex 0, the DFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack.",
                        "img2": "https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-1.png",
                        "ND3": "Next, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead.",
                        "img3": "https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-2.png",
                        "ND4": "Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.",
                        "img4": " https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-3.png",
                        "img5": "https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-4.png",
                        "ND5": "After we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph.",
                        "oper6": "https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-5.png",
                        "complex": "The code for the Depth First Search Algorithm with an example is shown below. The code has been simplified so that we can focus on the algorithm rather than other details.",
                        "complex1": "// DFS algorithm in C++<br><br>#include <iostream><br>#include <list><br>using namespace std;<br><br>class Graph {<br>  int numVertices;<br>  list<int> *adjLists;<br>  bool *visited;<br><br>   public:<br>  Graph(int V);<br>  void addEdge(int src, int dest);<br>  void DFS(int vertex);<br>}<br><br>// Initialize graph<br>Graph::Graph(int vertices) {<br>  numVertices = vertices;<br>  adjLists = new list<int>[vertices];<br>  visited = new bool[vertices];<br>}<br><br>// Add edges<br>void Graph::addEdge(int src, int dest) {<br>  adjLists[src].push_front(dest);<br>}<br><br>// DFS algorithm<br>void Graph::DFS(int vertex) {<br>  visited[vertex] = true;<br>  list<int> adjList = adjLists[vertex];<br><br>  cout << vertex << “ ”;<br><br>  list<int>::iterator i;<br>  for (i = adjList.begin(); i != adjList.end(); ++i)<br>    if (!visited[*i])<br>      DFS(*i);<br>}<br><br>int main() {<br>  Graph g(4);<br>  g.addEdge(0, 1);<br>  g.addEdge(0, 2);<br>  g.addEdge(1, 2);<br>  g.addEdge(2, 3);<br><br>  g.DFS(2);<br><br>  return 0;<br>}",
                        "complex2": "Complexity of Depth First Search",
                        "complex21": "The time complexity of the DFS algorithm is represented in the form of O(V + E), where V is the number of nodes and E is the number of edges.<br><br>The space complexity of the algorithm is O(V).",
                        "application": "1. For finding the path<br><br>2. To test if the graph is bipartite<br><br>3. For finding the strongly connected components of a graph<br><br>4. For detecting cycles in a graph"
                    }]
                }]
            }]
        },
        {
            "content": "Sorting Algorithms",
            "id": 5,
            "category": "Sort",
            "data": [{
                "content1": "Bubble Sort",
                "bai1": [{
                    "title": "In this tutorial, you will learn about the bubble sort algorithm.",
                    "noidung": [{
                        "DN": "Bubble sort is a sorting algorithm that compares two adjacent elements and swaps them until they are not in the intended order.<br><br>Just like the movement of air bubbles in the water that rise up to the surface, each element of the array move to the end in each iteration. Therefore, it is called a bubble sort.",
                        "oper1": "Working of Bubble Sort",
                        "ND1": "Suppose we are trying to sort the elements in ascending order.",
                        "oper2": "1. First Iteration (Compare and Swap)",
                        "ND21": "- Starting from the first index, compare the first and the second elements.<br><br>- If the first element is greater than the second element, they are swapped.<br><br>- Now, compare the second and the third elements. Swap them if they are not in order.<br><br>- The above process goes on until the last element.",
                        "img1": "https://cdn.programiz.com/cdn/farfuture/kn1zM7ZGIj60jcTe3mv8gAtbrvFHqxgqfQ7F9MdjPuA/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-0.png",
                        "oper3": "2. Remaining Iteration",
                        "ND31": "The same process goes on for the remaining iterations.<br><br>After each iteration, the largest element among the unsorted elements is placed at the end.",
                        "img2": "https://cdn.programiz.com/cdn/farfuture/LzbPYkOXS-DjqwLqtIrixMZCD1XLdU-JWWedrL1YIpw/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-1.png",
                        "ND32": "In each iteration, the comparison takes place up to the last unsorted element.",
                        "img3": "https://cdn.programiz.com/cdn/farfuture/-C5A9EpPrCAwR2TFQlZhG0uy5aSKmq-ewMaWyXp8_a8/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-2.png",
                        "ND33": "The array is sorted when all the unsorted elements are placed at their correct positions.",
                        "img4": "https://cdn.programiz.com/cdn/farfuture/NnXQeMGuMJnIH0qzC1C5n7r4FOynP9vu3cWEdCK5Qjk/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-3.png",
                        "complex1": "// Bubble sort in C++<br><br>#include <iostream><br>using namespace std;<br><br>// perform bubble sort<br>void bubbleSort(int array[], int size) {<br><br>  // loop to access each array element<br>for (int step = 0; step < size; ++step) {<br><br>    // loop to compare array elements<br>    for (int i = 0; i < size - step; ++i) {<br><br>      // compare two adjacent elements<br>      // change > to < to sort in descending order<br>      if (array[i] > array[i + 1]) {<br><br>        // swapping elements if elements<br>        // are not in the intended order<br>        int temp = array[i];<br>        array[i] = array[i + 1];<br>        array[i + 1] = temp;<br>      }<br>    }<br>  }<br>}<br><br>// print array<br>void printArray(int array[], int size) {<br>  for (int i = 0; i < size; ++i) {<br>    cout << “ ” << array[i];<br>  }<br>  cout << “\n”;<br>}<br><br>int main() {<br>  int data[] = {-2, 45, 0, 11, -9};<br><br>  // find array's length<br>  int size = sizeof(data) / sizeof(data[0]);<br><br>  bubbleSort(data, size);<br><br>  cout << “Sorted Array in Ascending Order:\n”;<br>  printArray(data, size);<br>}",
                        "complex2": "1. Time Complexities",
                        "complex21": "- Worst Case Complexity: O(n2)<br>If we want to sort in ascending order and the array is in descending order then the worst case occurs.<br><br>- Best Case Complexity: O(n)<br>If the array is already sorted, then there is no need for sorting.<br><br>- Average Case Complexity: O(n2)<br>It occurs when the elements of the array are in jumbled order (neither ascending nor descending).",
                        "complex3": "2. Space Complexity",
                        "complex31": "- Space complexity is O(1) because an extra variable is used for swapping.<br><br>- In the optimized bubble sort algorithm, two extra variables are used. Hence, the space complexity will be O(2).",
                        "application": "Bubble sort is used if<br><br>- complexity does not matter<br><br>- short and simple code is preferred"
                    }]
                }],
                "content2": "Selection Sort",
                "bai2": [{
                    "title": "In this tutorial, you will learn about the selection sort algorithm.",
                    "noidung": [{
                        "DN": "Selection sort is a sorting algorithm that selects the smallest element from an unsorted list in each iteration and places that element at the beginning of the unsorted list.",
                        "oper1": "Working of Selection Sort",
                        "ND11": "1. Set the first element as minimum.",
                        "img1": "https://cdn.programiz.com/cdn/farfuture/w1ZKsO2Obaw1WV03_lamX22SVyapwhbiKoLkT5Raiiw/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0-initial-array.png",
                        "ND12": "2. Compare minimum with the second element. If the second element is smaller than minimum, assign the second element as minimum.<br><br>Compare minimum with the third element. Again, if the third element is smaller, then assign minimum to the third element otherwise do nothing. The process goes on until the last element.",
                        "img2": "https://cdn.programiz.com/cdn/farfuture/9jjqXX0fGtJE2ul2Mga20fvf_GkNlFAFsDMwrrwFzbQ/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0-comparision.png",
                        "ND13": "3. After each iteration, minimum is placed in the front of the unsorted list.",
                        "img3": "https://cdn.programiz.com/cdn/farfuture/6o-qergdHNq6D7eBxBi87yIuCLc7MJy2BHR4QHeNxxQ/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0-swapping.png",
                        "ND14": "4. For each iteration, indexing starts from the first unsorted element. Step 1 to 3 are repeated until all the elements are placed at their correct positions.",
                        "img4": "https://cdn.programiz.com/cdn/farfuture/VPGtdVYag2vfHBotOaFEiYLqvWAD_Jwfnwur_AtKQHo/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0.png",
                        "img5": " https://cdn.programiz.com/cdn/farfuture/hgxXpCSrHui7tbyJUQNnh8N5l8MPbdbL6dlstS4-G3M/mtime:1582112622/sites/tutorial2program/files/Selection-sort-1.png",
                        "img6": "https://cdn.programiz.com/cdn/farfuture/mDT4W_wUoS9eYT1JoUWjZuh4XBVXGDuiV9cr4Rylggk/mtime:1582112622/sites/tutorial2program/files/Selection-sort-2.png",
                        "img7": "https://cdn.programiz.com/cdn/farfuture/dsZIa58W_SRP0yB21QmrWGQvrmob8yAVa94iCtIPWoo/mtime:1582112622/sites/tutorial2program/files/Selection-sort-3_1.png",
                        "complex1": "// Selection sort in C++<br><br>#include <iostream><br>using namespace std;<br><br>// function to swap the the position of two elements<br>void swap(int *a, int *b) {<br>  int temp = *a;<br>  *a = *b;<br>  *b = temp;<br>}<br><br>// function to print an array<br>void printArray(int array[], int size) {<br>  for (int i = 0; i < size; i++) {<br>    cout << array[i] << “ ”;<br>  }<br>  cout << endl;<br>}<br><br>void selectionSort(int array[], int size) {<br>  for (int step = 0; step < size - 1; step++) {<br>    int min_idx = step;<br>    for (int i = step + 1; i < size; i++) {<br><br>      // To sort in descending order, change > to < in this line.<br>      // Select the minimum element in each loop.<br>      if (array[i] < array[min_idx])<br>        min_idx = i;<br>    }<br><br>    // put min at the correct position<br>    swap(&array[min_idx], &array[step]);<br>  }<br>}<br><br>// driver code<br>int main() {<br>  int data[] = {20, 12, 10, 15, 2};<br>  int size = sizeof(data) / sizeof(data[0]);<br>  selectionSort(data, size);<br>  cout << “Sorted array in Acsending Order:\n”;<br>  printArray(data, size);<br>}",
                        "complex2": "Time Complexities:",
                        "complex21": "- Worst Case Complexity: O(n2)<br>If we want to sort in ascending order and the array is in descending order then, the worst case occurs.<br><br>- Best Case Complexity: O(n2)<br>It occurs when the array is already sorted<br><br>- Average Case Complexity: O(n2)<br>It occurs when the elements of the array are in jumbled order (neither ascending nor descending).<br><br>The time complexity of the selection sort is the same in all cases. At every step, you have to find the minimum element and put it in the right place. The minimum element is not known until the end of the array is not reached.",
                        "complex3": "Space Complexity:",
                        "complex31": "Space complexity is O(1) because an extra variable temp is used.",
                        "application": "The selection sort is used when<br><br>- a small list is to be sorted<br><br>- cost of swapping does not matter<br><br>- checking of all the elements is compulsory<br><br>- cost of writing to a memory matters like in flash memory (number of writes/swaps is O(n) as compared to O(n2) of bubble sort)"
                    }]
                }],
                "content3": "Insertion Sort",
                "bai3": [{
                    "title": "In this tutorial, you will learn about insertion sort algorithm.",
                    "noidung": [{
                        "DN": "Insertion sort is a sorting algorithm that places an unsorted element at its suitable place in each iteration.<br><br>Insertion sort works similarly as we sort cards in our hand in a card game.<br><br>We assume that the first card is already sorted then, we select an unsorted card. If the unsorted card is greater than the card in hand, it is placed on the right otherwise, to the left. In the same way, other unsorted cards are taken and put in their right place.<br><br>A similar approach is used by insertion sort.",
                        "oper1": "Suppose we need to sort the following array.",
                        "img1": "https://cdn.programiz.com/cdn/farfuture/K-kSm72ww4_afH0mQJDuR3Y-fPZYgBYo_Pclx7WlYUo/mtime:1582112622/sites/tutorial2program/files/Frame%204_0.png",
                        "ND1": "1. The first element in the array is assumed to be sorted. Take the second element and store it separately in key.<br><br>Compare key with the first element. If the first element is greater than key, then key is placed in front of the first element.",
                        "img2": "https://cdn.programiz.com/cdn/farfuture/l-X2VCkF2rp4i0X8mZX6BGJL_FQW9EL8PkKhBswQfpc/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-0_1.png",
                        "ND2": "2. Now, the first two elements are sorted.<br><br>Take the third element and compare it with the elements on the left of it. Placed it just behind the element smaller than it. If there is no element smaller than it, then place it at the beginning of the array.",
                        "img3": "https://cdn.programiz.com/cdn/farfuture/MqcrLAaQHEhcuJTmF_m712GG_wMemTY9AID0J9w4T6E/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-1_1.png",
                        "ND3": "3. Similarly, place every unsorted element at its correct position.",
                        "img4": "https://cdn.programiz.com/cdn/farfuture/hWFdFWWU0lZD2xWGz0CoMDESnjYa9Wg1HwpH99jTTH0/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-2_2.png",
                        "img5": "https://cdn.programiz.com/cdn/farfuture/TxAcrgHKfahw_BPEIKwCWB9BY2GNiI91yzWeetMfG9Q/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-3_2.png",
                        "complex1": "// Insertion sort in C++<br><br>#include <iostream><br>using namespace std;<br><br>// Function to print an array<br>void printArray(int array[], int size) {<br>  for (int i = 0; i < size; i++) {<br>    cout << array[i] << “ ”;<br>  }<br>  cout << endl;<br>}<br><br>void insertionSort(int array[], int size) {<br>  for (int step = 1; step < size; step++) {<br>    int key = array[step];<br>    int j = step - 1;<br><br>    // Compare key with each element on the left of it until an element smaller than<br>    // it is found.<br>    // For descending order, change key<array[j] to key>array[j].<br>    while (key < array[j] && j >= 0) {<br>      array[j + 1] = array[j];<br>      --j;<br>    }<br>array[j + 1] = key;<br>  }<br>}<br><br>// Driver code<br>int main() {<br>  int data[] = {9, 5, 1, 4, 3};<br> int size = sizeof(data) / sizeof(data[0]);<br>  insertionSort(data, size);<br>  cout << “Sorted array in ascending order:\n”;<br>  printArray(data, size);<br>}",
                        "complex2": "Time Complexities",
                        "complex21": "- Worst Case Complexity: O(n2)<br>Suppose, an array is in ascending order, and you want to sort it in descending order. In this case, worst case complexity occurs.<br><br>Each element has to be compared with each of the other elements so, for every nth element, (n-1) number of comparisons are made.<br><br>Thus, the total number of comparisons = n*(n-1) ~ n2<br><br>- Best Case Complexity: O(n)<br>When the array is already sorted, the outer loop runs for n number of times whereas the inner loop does not run at all. So, there are only n number of comparisons. Thus, complexity is linear.<br><br>- Average Case Complexity: O(n2)<br>It occurs when the elements of an array are in jumbled order (neither ascending nor descending).",
                        "complex3": "Space Complexity",
                        "complex31": "Space complexity is O(1) because an extra variable key is used.",
                        "application": "The insertion sort is used when:<br><br>- the array is has a small number of elements<br><br>- there are only a few elements left to be sorted"
                    }]
                }]
            }]
        },
        {
            "content": "Searching Algorithms",
            "id": 6,
            "category": "Searching",
            "data": [{
                "content1": "Linear Search",
                "bai1": [{
                    "title": "In this tutorial, you will learn about tree data structure.",
                    "noidung": [{
                        "DN": "A tree is a nonlinear hierarchical data structure that consists of nodes connected by edges.",
                        "oper1": "Why Tree Data Structure?",
                        "ND1": "Other data structures such as arrays, linked list, stack, and queue are linear data structures that store data sequentially. In order to perform any operation in a linear data structure, the time complexity increases with the increase in the data size. But, it is not acceptable in today's computational world.<br>Different tree data structures allow quicker and easier access to the data as it is a non-linear data structure.",
                        "oper2": "Tree Terminologies",
                        "ND21": "A node is an entity that contains a key or value and pointers to its child nodes.<br>The last nodes of each path are called leaf nodes or external nodes that do not contain a link/pointer to child nodes.<br>The node having at least a child node is called an internal node.",
                        "ND22": "It is the link between any two nodes.",
                        "ND23": "It is the topmost node of a tree.",
                        "ND24": "The height of a node is the number of edges from the node to the deepest leaf (ie. the longest path from the node to a leaf node).",
                        "ND25": "The depth of a node is the number of edges from the root to the node.",
                        "ND26": "The height of a Tree is the height of the root node or the depth of the deepest node.",
                        "ND27": "The degree of a node is the total number of branches of that node.",
                        "ND28": "A collection of disjoint trees is called a forest.<br>You can create a forest by cutting the root of a tree.",
                        "oper3": "Types of Tree",
                        "ND3": "- Binary Tree<br>- Binary Search Tree<br>- B-Tree",
                        "application": "1. Binary Search Trees(BSTs) are used to quickly check whether an element is present in a set or not.<br>2. Heap is a kind of tree that is used for heap sort.<br>3. A modified version of a tree called Tries is used in modern routers to store routing information.<br>4. Most popular databases use B-Trees and T-Trees, which are variants of the tree structure we learned above to store their data<br>5. Compilers use a syntax tree to validate the syntax of every program you write."
                    }]
                }],
                "content2": "Binary Search",
                "bai2": [{
                    "title": "In this tutorial, you will learn about binary tree and its different types.",
                    "noidung": [{
                        "DN": "A binary tree is a tree data structure in which each parent node can have at most two children. Each node of a binary tree consists of three items:<br>- data item<br>- address of left child<br>- address of right child",
                        "work": "A node of a binary tree is represented by a structure containing a data part and two pointers to other structures of the same type.",
                        "oper1": "Full Binary Tree",
                        "ND1": "A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.",
                        "oper2": "Perfect Binary Tree",
                        "ND2": "A perfect binary tree is a type of binary tree in which every internal node has exactly two child nodes and all the leaf nodes are at the same level.",
                        "oper3": "Complete Binary Tree",
                        "ND3": "A complete binary tree is just like a full binary tree, but with two major differences<br>1. Every level must be completely filled<br>2. All the leaf elements must lean towards the left.<br>3. The last leaf element might not have a right sibling i.e. a complete binary tree doesn't have to be a full binary tree.",
                        "oper4": "Degenerate or Pathological Tree",
                        "ND4": "A degenerate or pathological tree is the tree having a single child either left or right.",
                        "oper5": " Skewed Binary Tree",
                        "ND5": "A skewed binary tree is a pathological/degenerate tree in which the tree is either dominated by the left nodes or the right nodes. Thus, there are two types of skewed binary tree: left-skewed binary tree and right-skewed binary tree.",
                        "oper6": "Balanced Binary Tree",
                        "ND6": "It is a type of binary tree in which the difference between the height of the left and the right subtree for each node is either 0 or 1.",
                        "application": "1. For easy and quick access to data<br>2. In router algorithms<br>3. To implement heap data structure<br>4. Syntax tree"
                    }]
                }]
            }]
        },
        {
            "content": "Greedy Algorithms",
            "id": 7,
            "category": "Greedy",
            "data": [{
                "content1": "Greedy Algorithm",
                "bai1": [{
                    "title": "In this tutorial, you will learn about tree data structure.",
                    "noidung": [{
                        "DN": "A tree is a nonlinear hierarchical data structure that consists of nodes connected by edges.",
                        "oper1": "Why Tree Data Structure?",
                        "ND1": "Other data structures such as arrays, linked list, stack, and queue are linear data structures that store data sequentially. In order to perform any operation in a linear data structure, the time complexity increases with the increase in the data size. But, it is not acceptable in today's computational world.<br>Different tree data structures allow quicker and easier access to the data as it is a non-linear data structure.",
                        "oper2": "Tree Terminologies",
                        "ND21": "A node is an entity that contains a key or value and pointers to its child nodes.<br>The last nodes of each path are called leaf nodes or external nodes that do not contain a link/pointer to child nodes.<br>The node having at least a child node is called an internal node.",
                        "ND22": "It is the link between any two nodes.",
                        "ND23": "It is the topmost node of a tree.",
                        "ND24": "The height of a node is the number of edges from the node to the deepest leaf (ie. the longest path from the node to a leaf node).",
                        "ND25": "The depth of a node is the number of edges from the root to the node.",
                        "ND26": "The height of a Tree is the height of the root node or the depth of the deepest node.",
                        "ND27": "The degree of a node is the total number of branches of that node.",
                        "ND28": "A collection of disjoint trees is called a forest.<br>You can create a forest by cutting the root of a tree.",
                        "oper3": "Types of Tree",
                        "ND3": "- Binary Tree<br>- Binary Search Tree<br>- B-Tree",
                        "application": "1. Binary Search Trees(BSTs) are used to quickly check whether an element is present in a set or not.<br>2. Heap is a kind of tree that is used for heap sort.<br>3. A modified version of a tree called Tries is used in modern routers to store routing information.<br>4. Most popular databases use B-Trees and T-Trees, which are variants of the tree structure we learned above to store their data<br>5. Compilers use a syntax tree to validate the syntax of every program you write."
                    }]
                }],
                "content2": "Dijkstra's Algorithm",
                "bai2": [{
                    "title": "In this tutorial, you will learn about binary tree and its different types.",
                    "noidung": [{
                        "DN": "A binary tree is a tree data structure in which each parent node can have at most two children. Each node of a binary tree consists of three items:<br>- data item<br>- address of left child<br>- address of right child",
                        "work": "A node of a binary tree is represented by a structure containing a data part and two pointers to other structures of the same type.",
                        "oper1": "Full Binary Tree",
                        "ND1": "A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.",
                        "oper2": "Perfect Binary Tree",
                        "ND2": "A perfect binary tree is a type of binary tree in which every internal node has exactly two child nodes and all the leaf nodes are at the same level.",
                        "oper3": "Complete Binary Tree",
                        "ND3": "A complete binary tree is just like a full binary tree, but with two major differences<br>1. Every level must be completely filled<br>2. All the leaf elements must lean towards the left.<br>3. The last leaf element might not have a right sibling i.e. a complete binary tree doesn't have to be a full binary tree.",
                        "oper4": "Degenerate or Pathological Tree",
                        "ND4": "A degenerate or pathological tree is the tree having a single child either left or right.",
                        "oper5": " Skewed Binary Tree",
                        "ND5": "A skewed binary tree is a pathological/degenerate tree in which the tree is either dominated by the left nodes or the right nodes. Thus, there are two types of skewed binary tree: left-skewed binary tree and right-skewed binary tree.",
                        "oper6": "Balanced Binary Tree",
                        "ND6": "It is a type of binary tree in which the difference between the height of the left and the right subtree for each node is either 0 or 1.",
                        "application": "1. For easy and quick access to data<br>2. In router algorithms<br>3. To implement heap data structure<br>4. Syntax tree"
                    }]
                }],
                "content3": "Kruskal's Algorithm",
                "bai3": [{
                    "title": "In this tutorial, you will learn about binary tree and its different types.",
                    "noidung": [{
                        "DN": "A binary tree is a tree data structure in which each parent node can have at most two children. Each node of a binary tree consists of three items:<br>- data item<br>- address of left child<br>- address of right child",
                        "work": "A node of a binary tree is represented by a structure containing a data part and two pointers to other structures of the same type.",
                        "oper1": "Full Binary Tree",
                        "ND1": "A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.",
                        "oper2": "Perfect Binary Tree",
                        "ND2": "A perfect binary tree is a type of binary tree in which every internal node has exactly two child nodes and all the leaf nodes are at the same level.",
                        "oper3": "Complete Binary Tree",
                        "ND3": "A complete binary tree is just like a full binary tree, but with two major differences<br>1. Every level must be completely filled<br>2. All the leaf elements must lean towards the left.<br>3. The last leaf element might not have a right sibling i.e. a complete binary tree doesn't have to be a full binary tree.",
                        "oper4": "Degenerate or Pathological Tree",
                        "ND4": "A degenerate or pathological tree is the tree having a single child either left or right.",
                        "oper5": " Skewed Binary Tree",
                        "ND5": "A skewed binary tree is a pathological/degenerate tree in which the tree is either dominated by the left nodes or the right nodes. Thus, there are two types of skewed binary tree: left-skewed binary tree and right-skewed binary tree.",
                        "oper6": "Balanced Binary Tree",
                        "ND6": "It is a type of binary tree in which the difference between the height of the left and the right subtree for each node is either 0 or 1.",
                        "application": "1. For easy and quick access to data<br>2. In router algorithms<br>3. To implement heap data structure<br>4. Syntax tree"
                    }]
                }]
            }]
        }
    ]
}